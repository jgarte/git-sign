#!/bin/bash

set -euo pipefail
IFS=
# remember, *still* need to quote variables!

#set -x

usage () {
    echo "usage: $0 tagname"
    echo 
    echo "  verifies a signed tag, both the tag signature and then any"
    echo "  SHA-256 hash lists embedded within the tag message (to have"
    echo "  secure signing while git signatures still only rely on SHA-1)"
    echo 
    echo "  Options:"
    echo "    --accept-keys fp1,fp2,.."
    echo "         only accept the listed keys (full fingerprints with or"
    echo "         without spaces). Alternatively the VERIFY_SIG_ACCEPT_KEYS"
    echo "         env var can be set to the same. If neither is set, any key"
    echo "         on the local keyring that has a trust path is accepted."
    echo "    --require-accept-keys"
    echo "         fail unless VERIFY_SIG_ACCEPT_KEYS or --accept-keys is"
    echo "         given."
    exit 1
}


unset tagname
acceptkeys=${VERIFY_SIG_ACCEPT_KEYS-}
requireacceptkeys=0

while [ "${#@}" -gt 0 ]; do
    case "$1" in
	-h|--help)
	    usage
	    ;;
	--accept-keys)
	    shift
	    acceptkeys="$1"
	    shift
	    ;;
	--require-accept-keys)
	    shift
	    requireacceptkeys=1
	    ;;
	*)
	    if [ -n "${tagname-}" ]; then
		usage
	    fi
	    tagname="$1"
	    shift
	    ;;
    esac
done

if [ -z "${tagname-}" ]; then
    usage
fi

if [ "$requireacceptkeys" -ne 0 ]; then
    if [ -z "$acceptkeys" ]; then
	echo "$0: --require-accept-keys was given but neither VERIFY_SIG_ACCEPT_KEYS nor --accept-keys list any keys" # >&2
	exit 1
    fi
fi


exitcode=0

tagcontents=`mktemp`
git cat-file tag "$tagname" > "$tagcontents"
# (somewhat irritatingly, git cat-file does not accept "--" as option
# processing terminator)

tagbase=`mktemp -d`
grep -A9999 -E '^-----BEGIN PGP SIGNATURE-----$' < "$tagcontents" > "$tagbase"/tagmessage.sig
siglen=`wc -l < "$tagbase"/tagmessage.sig`
tac < "$tagcontents" | tail -n+$(( $siglen + 1 )) | tac > "$tagbase"/tagmessage

echo "(1) Verifying PGP signature"
(
    set -euo pipefail
    cd "$tagbase"
    # sorry, have to ignore your language settings
    LANG=C gpg -v --verify tagmessage.sig 2>&1 | tee out
)

if egrep -q "digest algorithm (SHA1|MD5)\b" "$tagbase"/out; then
    echo "$0: insecure digest algorithm, aborting!"
    exit 1
fi

# Bash should have terminated above if gpg in the subshell didn't
# succeed already; but be paranoid:
if ! egrep -q "^gpg: Good signature" "$tagbase"/out; then
    echo "$0: missing 'Good signature', BUG, aborting!"
    exit 1
fi

# Don't accept good signatures from keys without a trust path
if egrep -q "^gpg: WARNING:" "$tagbase"/out; then
    fp=$(cat "$tagbase"/out | perl -wne 'if (($k)=m/Primary key fingerprint: ([A-F0-9 ]+)/) { $k=~ s/\s//sg; print $k or die; exit}')
    echo "$0: Not accepting signatures from keys without a trust path, aborting."
    echo "$0: Please create a trust path. If you're confident that this key belongs"
    echo "$0: to the claimed user, sign it via 'gpg --sign-key $fp'."
    exit 1
fi


# Verify key to be one of the accepted keys, if specified:

error_fprs() {
    echo "$0: error: expected exactly 1 entry for '$1' in:"
    cat "$tagbase"/fprs
    exit 1
}

if [ -n "$acceptkeys" ]; then

    if ! id=$(perl -wne ' BEGIN { $exitcode= 1 }
           if (($k)=m/using .*key ([A-F0-9]{16,})\b/) { 
                print $k or die; 
                $exitcode=0;
                exit
           } 
           END { exit $exitcode }' < "$tagbase"/out); then
	echo "$0: could not find 16+ digit key id in gpg output"
	exit 1
    fi
    
    # retrieve fingerprints for this key:
    if ! gpg --fingerprint --with-colons "$id" > "$tagbase"/fprs; then
	echo "$0: failed to retrieve fingerprints for key '$id'"
	exit 1
    fi

    # keys might not have a UID, hence also test for 'tru' field (XX: check spec for fields)
    if [ "$(grep ^tru: "$tagbase"/fprs | wc -l)" -ne 1 ]; then
	error_fprs tru
    fi
    # Is it OK to not accept keys without uid?
    if [ "$(grep ^uid: "$tagbase"/fprs | wc -l)" -ne 1 ]; then
	error_fprs uid
    fi

    if ! ACCEPTKEYS="$acceptkeys" perl -we ' use strict; use warnings FATAL => "uninitialized"; 
            my %k= map { s/\s//sg; $_=> 1 } split /,/, $ENV{ACCEPTKEYS};
            my @accepted= grep { $k{$_} } map { chomp; (split /:/)[9] } grep { /^fpr:/ } <STDIN>;
            exit (@accepted ? 0 : 1)
    ' < "$tagbase"/fprs; then
	echo "$0: key id '$id' does not resolve into any fingerprint that is contained in the list: $acceptkeys"
	exit 1
    fi
fi


echo
echo "(2) Verifying git-sign message"

numfiles1=`mktemp`
grep -A1 -E '^\$ git ls-files -z \|.* perl.*\+\+ while' < "$tagbase"/tagmessage > "$numfiles1"
numfiles=`mktemp`
tail -n+2 < "$numfiles1" > "$numfiles"

nsig=`cat "$numfiles"`
ngit=`git ls-files -z | perl -we '$/="\0"; $z++ while <STDIN>; print "$z\n"'`

if [ "$nsig" = "$ngit" ]; then
    nums=OK
else
    nums="NOT OK, git shows $ngit files, the message $nsig"
    exitcode=1
fi

hashes1=`mktemp`
grep -A9999999 -E '^\$ git ls-files -z \|.* sha256sum' < "$tagbase"/tagmessage > "$hashes1"
hashes=`mktemp`
tail -n+2 < "$hashes1" > "$hashes"

if sha256sum -c "$hashes"; then
    sigs=OK
else
    sigs="NOT OK (differences see above)"
    exitcode=1
fi

echo
echo "==> number of files: $nums"
echo "    hash sums: $sigs"

rm "$hashes" "$hashes1" "$numfiles1" "$numfiles" "$tagcontents"
rm -rf "$tagbase"

exit "$exitcode"
